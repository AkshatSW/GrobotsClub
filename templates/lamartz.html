<section class="image-loop"></section>
    <div class="wrapper">
      <!-- Columns will be dynamically generated by JavaScript -->
    </div>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      .wrapper {
        display: flex;
        width: 100%;
        height: 100vh;
        flex-wrap: nowrap;
        gap: 2%;
        overflow: hidden;
      }

      .column {
        width: 32%;
        display: flex;
        flex-direction: column;
      }

      .column .item {
        width: 100%;
        height: 300px;
        margin-bottom: 10px;
      }

      .column .item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        object-position: center;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.1/gsap.min.js"></script>
    <script>
      console.clear();

      const columns = 3; // Number of columns
      const imagesPerColumn = 6; // Number of images per column
      const basePath = "static/assets/images/empYoungMinds/lamartz";
      const imageRange = [1, 19]; // Image range from 1 to 19

      const wrapper = document.querySelector(".wrapper");

      function createImageElement(index) {
        const img = document.createElement("img");
        img.src = `${basePath}/${index}.jpg`;
        img.alt = "";
        return img;
      }

      function createColumn(startIndex) {
        const column = document.createElement("div");
        column.classList.add("column");
        for (let i = 0; i < imagesPerColumn; i++) {
          const item = document.createElement("div");
          item.classList.add("item");
          item.appendChild(createImageElement(startIndex + i));
          column.appendChild(item);
        }
        return column;
      }

      // Populate columns
      for (let i = 0; i < columns; i++) {
        wrapper.appendChild(createColumn(i * imagesPerColumn + 1));
      }

      window.addEventListener("load", () => {
        const columnsElements = gsap.utils.toArray(".column");
        const loops = columnsElements.map((column) => {
          const items = gsap.utils.toArray(".item", column);
          return verticalLoop(items, {
            repeat: -1,
            paddingBottom: 10
          });
        });
      });

      function verticalLoop(items, config) {
        let timeline;
        items = gsap.utils.toArray(items);
        config = config || {};
        gsap.context(() => {
          let onChange = config.onChange,
            lastIndex = 0,
            tl = gsap.timeline({
              repeat: config.repeat,
              onUpdate:
                onChange &&
                function () {
                  let i = tl.closestIndex();
                  if (lastIndex !== i) {
                    lastIndex = i;
                    onChange(items[i], i);
                  }
                },
              paused: config.paused,
              defaults: { ease: "none" },
              onReverseComplete: () =>
                tl.totalTime(tl.rawTime() + tl.duration() * 100)
            }),
            length = items.length,
            startY = items[0].offsetTop,
            times = [],
            heights = [],
            spaceBefore = [],
            yPercents = [],
            curIndex = 0,
            center = config.center,
            clone = (obj) => {
              let result = {},
                p;
              for (p in obj) {
                result[p] = obj[p];
              }
              return result;
            },
            pixelsPerSecond = (config.speed || 1) * 100,
            snap =
              config.snap === false ? (v) => v : gsap.utils.snap(config.snap || 1),
            timeOffset = 0,
            container =
              center === true
                ? items[0].parentNode
                : gsap.utils.toArray(center)[0] || items[0].parentNode,
            totalHeight,
            getTotalHeight = () =>
              items[length - 1].offsetTop +
              (yPercents[length - 1] / 100) * heights[length - 1] -
              startY +
              spaceBefore[0] +
              items[length - 1].offsetHeight *
                gsap.getProperty(items[length - 1], "scaleY") +
              (parseFloat(config.paddingBottom) || 0),
            populateHeights = () => {
              let b1 = container.getBoundingClientRect(),
                b2;
              startY = items[0].offsetTop;
              items.forEach((el, i) => {
                heights[i] = parseFloat(gsap.getProperty(el, "height", "px"));
                yPercents[i] = snap(
                  (parseFloat(gsap.getProperty(el, "y", "px")) / heights[i]) * 100 +
                    gsap.getProperty(el, "yPercent")
                );
                b2 = el.getBoundingClientRect();
                spaceBefore[i] = b2.top - (i ? b1.bottom : b1.top);
                b1 = b2;
              });
              gsap.set(items, {
                yPercent: (i) => yPercents[i]
              });
              totalHeight = getTotalHeight();
            },
            timeWrap,
            populateOffsets = () => {
              timeOffset = center
                ? (tl.duration() * (container.offsetWidth / 2)) / totalHeight
                : 0;
              center &&
                times.forEach((t, i) => {
                  times[i] = timeWrap(
                    tl.labels["label" + i] +
                      (tl.duration() * heights[i]) / 2 / totalHeight -
                      timeOffset
                  );
                });
            },
            getClosest = (values, value, wrap) => {
              let i = values.length,
                closest = 1e10,
                index = 0,
                d;
              while (i--) {
                d = Math.abs(values[i] - value);
                if (d > wrap / 2) {
                  d = wrap - d;
                }
                if (d < closest) {
                  closest = d;
                  index = i;
                }
              }
              return index;
            },
            populateTimeline = () => {
              let i, item, curY, distanceToStart, distanceToLoop;
              tl.clear();
              for (i = 0; i < length; i++) {
                item = items[i];
                curY = (yPercents[i] / 100) * heights[i];
                distanceToStart = item.offsetTop + curY - startY + spaceBefore[0];
                distanceToLoop =
                  distanceToStart + heights[i] * gsap.getProperty(item, "scaleY");
                tl.to(
                  item,
                  {
                    yPercent: snap(((curY - distanceToLoop) / heights[i]) * 100),
                    duration: distanceToLoop / pixelsPerSecond
                  },
                  0
                )
                  .fromTo(
                    item,
                    {
                      yPercent: snap(
                        ((curY - distanceToLoop + totalHeight) / heights[i]) * 100
                      )
                    },
                    {
                      yPercent: yPercents[i],
                      duration:
                        (curY - distanceToLoop + totalHeight - curY) /
                        pixelsPerSecond,
                      immediateRender: false
                    },
                    distanceToLoop / pixelsPerSecond
                  )
                  .add("label" + i, distanceToStart / pixelsPerSecond);
                times[i] = distanceToStart / pixelsPerSecond;
              }
              timeWrap = gsap.utils.wrap(0, tl.duration());
            },
            customAnimations = () => {
              let { enterAnimation, leaveAnimation } = config,
                eachDuration = tl.duration() / items.length;
              items.forEach((item, i) => {
                let anim = enterAnimation && enterAnimation(item, eachDuration, i),
                  isAtEnd =
                    anim &&
                    tl.duration() -
                      timeWrap(times[i] - Math.min(eachDuration, anim.duration())) <
                      eachDuration - 0.05;
                anim &&
                  tl.add(anim, isAtEnd ? 0 : timeWrap(times[i] - anim.duration()));
                anim = leaveAnimation && leaveAnimation(item, eachDuration, i);
                isAtEnd = times[i] === tl.duration();
                anim && anim.duration() > eachDuration && anim.duration(eachDuration);
                anim && tl.add(anim, isAtEnd ? 0 : times[i]);
              });
            },
            refresh = (deep) => {
              let progress = tl.progress();
              tl.progress(0, true);
              populateHeights();
              deep && populateTimeline();
              populateOffsets();
              customAnimations();
              deep && tl.draggable
                ? tl.time(times[curIndex], true)
                : tl.progress(progress, true);
            },
            onResize = () => refresh(true),
            proxy;
          gsap.set(items, { y: 0 });
          populateHeights();
          populateTimeline();
          populateOffsets();
          customAnimations();
          window.addEventListener("resize", onResize);
          if (container.offsetWidth <= 1) {
            proxy = gsap.quickSetter(container, "width", "px");
            gsap.set(container, { width: container.scrollWidth });
            proxy(0);
          }
        }, document);
        return tl;
      }
    </script>
  </section>